# 1. RDMS 및 Oracle 소개

## Oracle
- Oracle DBMS는 미국에 본사를 둔 Oracle사에서 공급하는 상용DBMS이다.
- Oracle이 제공하는 DBMS는 다양하고 강력한 기능으로 전 세계적으로 가장 높은 시장 점유율을 가지고 있으며 많은 기업에서 사용된다.
- 이런 특징으로 Oracle DBMS 전문인력에 대한 수요는 매우 높고 개발자들이 참조할 수 있는 Reference와 Commuity는 양과 질의 관점에서 잘 구축돼 있다.

![](./img/oracle.png)
Background Process: 명령어 셋

# 2. Oracle의 주요 개념

## Oracle Data Type

### 문자형 Data Type

- 문자 형태를 갖는 Data Type
- 문자 형태는 Data에 저장되는 자료 중 대부분을 점유하는 Type

    - varchar2  VARCHAR2(size [BYTE | CHAR])    //가변형 문자열 저장. 1~4000byte 까지 저장 가능.
    - nvarchar2 NVARCHAR2(size) National Character를 위한 가변 문자열 저장. 1~4000byte까지 저장 가능
    - char  CHAR[(size [BYTE | CHAR])]  고정된 길이 문자열 저장. 1~2000byte까지 저장 가능. 지정된 길이보다 짧은 길이의 자료가 입력될 경우 공백(space) 가 오른쪽에 추가돼 지정된 길이만큼 저장됨.
    - long  LONG    2GB 까지 저장 가능한 가변 길이 문자열 저장. 사용 및 관리상의 문제로 많이 사용하지 않으며 LOB 형태를 사용 할 것을 권함.
    - clob  CLOB    (4 GB -1)*DB_BLOCK_SIZE (8TB to 128TB) 까지의 문자열 저장 가능.

### 실습 2-1 varchar2 Type의 특성

```sql

SQL> drop table tab_test01;
drop table tab_test01
           *
ERROR at line 1:
ORA-00942: table or view does not exist


SQL> create table tab_test01
  2  (
  3    c1 varchar2(10)
  4    ,c2 varchar2(4000)
  5  );

Table created.

SQL>
SQL> insert into tab_test01(c1) values(dbms_random.string('X',10));
# 10byte의 문자열을 생성해 C1칼럼에 입력.
1 row created.

SQL> insert into tab_test01(c1) values(dbms_random.string('X',20));
insert into tab_test01(c1) values(dbms_random.string('X',20))
# 20byte의 문자열을 생성해 C1칼럼에 입력.
                                              *
ERROR at line 1: # 적재 가능한 최대 길이를 초과하므로 실패
ORA-12899: value too large for column "BO"."TAB_TEST01"."C1" (actual: 20,
maximum: 10)


SQL> select lengthb(c1) from tab_test01;

LENGTHB(C1)
-----------
         10

SQL> insert into tab_test01(c2) values(dbms_random.string('X',4000));
# 4000byte로 선언한 C2칼럼에 dbms_random Package의 string Function을 사용해 4000 byte를 생성해 입력

1 row created.

SQL> insert into tab_test01(c2) values(dbms_random.string('X',5000));

1 row created.

SQL> insert into tab_test01(c2) values(rpad('A',5000,'A'));
# varchar2 Type의 return값을 갖는 함수는 최대 4000byte 까지만 return 하기 때문에 오류가 발생하지 않는다.
1 row created.

SQL> select lengthb(c2) from tab_test01 where c2 is not null;

LENGTHB(C2)
-----------
       4000
       4000
       4000

```

C1 칼럼은 10byte, C2 칼럼은 varchar2 Type의 최대 길이인 4000 byte.

dbms_random Package의  string function은 지정한 개수 만큼의 문자열을 생성하고 varchar2 형태로 return 합니다.


### 실습 2-2 varchar2 Type 의 특성 - 최대길이.

```sql
SQL> drop table tab_test01;

Table dropped.

SQL> create table tab_test01
  2  (
  3    c1 varchar2(4000)
  4    ,c2 nvarchar2(2000)
  5  );

Table created.

SQL>
SQL> set serveroutput on
SQL> declare
  2    i number;
  3    v_str varchar2(32767);
  4    v_len1 number;
  5    v_len2 number;
  6  begin
  7    delete tab_test01;
  8    insert into tab_test01(c1) values(dbms_random.string('X',400));
  9    for i in 1..100 loop
 10      v_str:=dbms_random.string('X',400);
 11      select length(c1),lengthb(c1) into v_len1,v_len2 from tab_test01;
 12      dbms_output.put_line('i:' || i || ', length:' || to_char(v_len1) || ', lengthb:' || to_char(v_len2));
 13      update tab_test01 set c1=c1||v_str;
 14    end loop;
 15  end;
 16  /
i:1, length:400, lengthb:400
i:2, length:800, lengthb:800
i:3, length:1200, lengthb:1200
i:4, length:1600, lengthb:1600
i:5, length:2000, lengthb:2000
i:6, length:2400, lengthb:2400
i:7, length:2800, lengthb:2800
i:8, length:3200, lengthb:3200
i:9, length:3600, lengthb:3600
i:10, length:4000, lengthb:4000
declare
*
ERROR at line 1:
ORA-01489: result of string concatenation is too long
ORA-06512: at line 13


SQL>
SQL> set serveroutput on
SQL> declare
  2    i number;
  3    v_str varchar2(32767);
  4    v_len1 number;
  5    v_len2 number;
  6  begin
  7    delete tab_test01;
  8    insert into tab_test01(c2) values(dbms_random.string('X',400));
  9    for i in 1..100 loop
 10      v_str:=dbms_random.string('X',400);
 11      select length(c2),lengthb(c2) into v_len1,v_len2 from tab_test01;
 12      dbms_output.put_line('i:' || i || ', length:' || to_char(v_len1) || ', lengthb:' || to_char(v_len2));
 13      update tab_test01 set c2=c2||v_str;
 14    end loop;
 15  end;
 16  /
i:1, length:400, lengthb:800
i:2, length:800, lengthb:1600
i:3, length:1200, lengthb:2400
i:4, length:1600, lengthb:3200
i:5, length:2000, lengthb:4000
declare
*
ERROR at line 1:
ORA-01489: result of string concatenation is too long
ORA-06512: at line 13

```
> 위 예제는 문자 400개를 초기에 입력후 400개씩 추가해 update한다. 10번째 update를 시도하는 과정에서 오류가 발생하는데 최초 입력된 400개의 문자열에 400개의 문자열이 9번 더 추가되어 400+3200 = 4000 , 4000byte가 소진 됐기 때문이다.


length() 함수는 문자 수를 돌려주는 반면 lengthb() 함수는 byte 수를 돌려준다.

varchar2 Type은 입력된 문자 수와 byte수가 차이 나지 않지만, nvarchar2의 경우 문자당 2byte를 점유하므로 length()함수와 lengthb() 함수의 결과가 다르게 나온다.


### 실습 2-3 char Type의 특성

```sql
SQL> drop table tab_test01;

Table dropped.

SQL> create table tab_test01
  2  (
  3    c1 char(2000)
  4    ,c2 varchar2(2000)
  5  );

Table created.

SQL>
SQL> set serveroutput on
SQL> declare
  2    i number;
  3    v_str varchar2(4000);
  4    v_len1 number;
  5    v_len2 number;
  6  begin
  7    delete tab_test01;
  8    insert into tab_test01(c1) values(dbms_random.string('X',100));
  9    for i in 1..10 loop
 10      v_str:=dbms_random.string('X',100);
 11      select length(c1),lengthb(c1) into v_len1,v_len2 from tab_test01;
 12      dbms_output.put_line('i:' || i || ', length:' || to_char(v_len1) || ', lengthb:' || to_char(v_len2));
 13      update tab_test01 set c1=c1||v_str;
 14    end loop;
 15  end;
 16  /
i:1, length:2000, lengthb:2000
declare
*
ERROR at line 1:
ORA-12899: value too large for column "BO"."TAB_TEST01"."C1" (actual: 2100, maximum: 2000)
ORA-06512: at line 13


SQL> insert into tab_test01(c1,c2) values(rpad('A',10,'A'),rpad('A',10,'A'));

1 row created.

SQL> select length(c1),length(c2) from tab_test01;

LENGTH(C1) LENGTH(C2)
---------- ----------
      2000         10
```

> C1은 char Type으로 2000 byte 크기로 선언. 2-2와 같이 update 도중 오류가 발생하는데 같은이유로 오류발생. 하지만 varchar2는 10byte만 입력하면 10byte만 사용하지만 char는 한번 입력시 2000byte를 점유한다.

### 실습 2-4 varchar2 컬럼과 char 컬럼의 비교

```sql
SQL> delete tab_test01;

1 row deleted.

SQL> insert into tab_test01(c1,c2) values('A','A');

1 row created.

SQL>
SQL> col c1 form a20
SQL> col c2 form a20
SQL>
SQL> select trim(c1) c1,c2,length(c1),length(c2) from tab_test01 where c1='A';

C1                   C2                   LENGTH(C1) LENGTH(C2)
-------------------- -------------------- ---------- ----------
A                    A                          2000          1

1 row selected.

SQL> select trim(c1) c1,c2,length(c1),length(c2) from tab_test01 where c2='A';

C1                   C2                   LENGTH(C1) LENGTH(C2)
-------------------- -------------------- ---------- ----------
A                    A                          2000          1

1 row selected.

SQL> select trim(c1) c1,c2,length(c1),length(c2) from tab_test01 where c1=c2;

no rows selected

SQL>
SQL> select trim(c1) c1,c2,length(c1),length(c2) from tab_test01 where trim(c1)=c2;

C1                   C2                   LENGTH(C1) LENGTH(C2)
-------------------- -------------------- ---------- ----------
A                    A                          2000          1

1 row selected.

SQL> select trim(c1) c1,c2,length(c1),length(c2) from tab_test01 where c1=rpad(c2,2000,' ');

C1                   C2                   LENGTH(C1) LENGTH(C2)
-------------------- -------------------- ---------- ----------
A                    A                          2000          1

```
> C1은 char(10), C2는 varchar2(10)로 정의되어 있다. 양쪽 컬럼에 모두 'A'를 입력하고 C1='A', C2='A'로 검색해 보면 검색이 잘된다. 하지만 C1=C2로 비교를 하면 결과가 나오지 않는다.

> 상수값 'A' 가 입력된 경우는 길이를 동일하게 만들어 처리해 비교하지만, varchar2는 공백을 붙여 비교하는 대상이 되지 않으므로 char Type과 비교 시 길이가 달라 동일한 자료로 인식되지 못한다. 의미적으로 동일한 자료가 char, varchar2로 저장돼 있다면 이들 값에 대한 비교 시 위의 예시처럼 trim()함수를 통해 불필요한 공백을 제거하거나 char , nchar등에서 처리하는 것처럼 rpad() 함수를 통해 길이가 짧은 문자열에 공백을 추가해야한다.

